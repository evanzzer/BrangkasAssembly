;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Fri Apr 9 2021
; Processor: AT89C51
; Compiler:  ASEM-51 (Proteus)
;====================================================================

$NOMOD51
$INCLUDE (8051.MCU)

DATAPASS EQU 500H
PRESSED BIT P0.0	; SINCE P0 IS NOT USED, WE USE P0 AS BINARY MEMORY
RSTSIG BIT P0.1		; FIRST STAGE RESET PASSWORD, BOOLEAN FOR KEYPAD AND INIT
RSTCALL BIT P0.2	; SECOND STAGE RESET PASSWORD, CONFIRMING OLD PASSWORD
RSTMODE1 BIT P0.3	; THIRD STAGE RESET PASSWORD, INPUT NEW PASSWORD
RSTMODE2 BIT P0.4	; FOURTH STAGE RESET PASSWORD, CONFIRMING NEW PASSWORD

ORG 00H
	MOV P0, #00H	; SET ALL BINARY MEMORY P0 TO 0
	MOV P1, #01H	; SWITCH, PUSH BUTTON, LCD PIN
	MOV P2, #0FFH	; KEYPAD
	MOV R0, #04H	; ITERATOR
	MOV DPTR, #DATAPASS

; ===== MOVE THE DEFAULT PIN FROM ROM TO THE RAM =====
MOVPWD:	MOV A, R0	; MOVE THE ITERATOR TO A
	SETB PSW.4		; CHANGE TO REGISTER BANK 3 (CACHE)
	SETB PSW.3
	ADD A, #20H		; ADD A TO THE ADDRESS HIGHER THAN REGISTER BANK TO STORE THE PASSWORD
	MOV R0, A		; PUT THE A (THE ADDRESS WHERE PASS WILL BE STORED) TO R0
	MOV A, 00H		; GET THE ITERATOR AGAIN FROM R0 IN THE REGISTER BANK 0
	DEC A			; DECREMENT A
	MOVC A, @A+DPTR	; GET THE DEFAULT PASSWORD FROM ROM
	MOV @R0, A		; MOVE TO THE ADDRESS WHERE R0 POINTS TO
	CLR PSW.4		; CHANGE BACK TO REGISTER BANK 0
	CLR PSW.3
	DJNZ R0, MOVPWD	; ITERATE UNTIL 4 PINS HAVE BEEN MOVED

	; LCD INITIALIZATION
	MOV A, #38H		; 16x2, 5x7 DOT MATRIC DISPLAY
	ACALL COMM
	MOV A, #0CH		; SET LCD DISPLAY ON, CURSOR OFF, BLINKING OFF
	ACALL COMM

	; SERVO INITIALIZATION
	ACALL SRVCLR	; CALL SERVO AT CLOSE STATE
	
INIT:	MOV A, #01H	; CLEAR THE DISPLAY
	ACALL COMM
	MOV P1, #01H	; NULLIFY ALL I/O PORT
	MOV P2, #0FFH 	
	MOV R0, #04H

	JB RSTSIG, INIT2	; IF RESET MODE IS ACTIVE, JUMP TO INIT2

	MOV A, #84H		; SET LCD CURSOR TO 1st ROW, 5th COLUMN
	ACALL COMM
	MOV DPTR, #PWDTXT	; DISPLAY THE PASSWORD TEXT
	ACALL READSTR
	MOV A, #0C6H	; SET LCD CURSOR TO 2nd ROW, 7th COLUMN
	ACALL COMM
	SJMP CHECK

INIT2:	CLR RSTSIG	; CLEAR THE FIRST RESET
	SETB RSTCALL	; SET THE SECOND RESET
	MOV A, #80H		; MOVE CURSOR TO 1st ROW, 1st COLUMN
	ACALL COMM
	MOV DPTR, #RSTTXT	; DISPLAY THE RESET TEXT
	ACALL READSTR
	MOV A, #0C6H	; SET LCD CURSOR TO 2nd ROW, 7th COLUMN
	ACALL COMM

; === KEYPAD CODE, A TO D AS OUTPUT, 1 TO 3 AS INPUT ===
CHECK:	MOV A, #01H ; RANGE 1-3, 1 AS DEFAULT
	MOV P2, #0FEH	; SET ACTIVE BIT TO P2.0
	ACALL COLCHK	; CHECK INPUT

	JB PRESSED, STORE	; STORE IF THERE IS INPUT

	MOV A, #04H		; RANGE 4-6, 4 AS DEFAULT
	MOV P2, #0FDH	; SET ACTIVE BIT TO P2.1
	ACALL COLCHK	; CHECK INPUT

	JB PRESSED, STORE	; STORE IF THERE IS INPUT

	MOV A, #07H		; RANGE 7-9, 7 AS DEFAULT
	MOV P2, #0FBH	; SET ACTIVE BIT TO P2.2
	ACALL COLCHK

	JB PRESSED, STORE

	MOV A, #00H		; ONLY 0 EXIST IN THIS ROW
	MOV P2, #0F7H	; SET ACTIVE BIT TO P2.3
	ACALL COLRST	; CHECK IF 0 WAS PRESSED

	JB PRESSED, STORE
	JB RSTSIG, INIT

	JMP CHECK	; NOTHING, BACK TO CHECKING

COLCHK:	CLR PRESSED	; SET BOOLEAN TO FALSE

	JB P2.4, COL2	; NOTHING PRESSED IN (1), MOVE TO NEXT COL
	JNB P2.4, $		; WAIT UNTIL BUTTON HAS BEEN RELEASED 
	SETB PRESSED	; BUTTON HAS BEEN PRESSED, SET BOOLEAN TO TRUE
	RET

COL2:	JB P2.5, COL3	; NOTHING PRESSED 
	JNB P2.5, $		; WAIT TILL BUTTON HAS BEEN RELEASED
	INC A			; ADD DEFAULT VALUE BY 1
	SETB PRESSED	; SET BOOLEAN TO TRUE
	RET

COL3:	JB P2.6, RETURN	; NOTHING HAS BEEN PRESSED HERE. CURRENT ROW DOESN'T HAVE ANY INPUT
	JNB P2.6, $		; WAIT TILL BUTTON HAS BEEN RELEASED
	INC A			; ADD DEFAULT VALUE BY 2
	INC A
	SETB PRESSED
	RET

; == RETURN TO LAST ACALL ==
RETURN:	RET

COLRST: JB P2.4, COLZERO	; CHECK IF ASTERISK BUTTON HAS BEEN PRESSED
	JB P2.4, $				; WAIT UNTIL THE BUTTON HAS BEEN RELEASED
	JB RSTCALL, COLZERO		; IF IN RESET MODE, JUST IGNORE
	JB RSTMODE1, COLZERO
	JB RSTMODE2, COLZERO
	SETB RSTSIG				; NOT IN RESET MODE, SET INTO RESET MODE
	RET

; ===== STORE SECTION =====
COLZERO:JB P2.5, RETURN	; NOTHING HAS BEEN PRESSED HERE. NO INPUT
	JNB P2.5, $
	SETB PRESSED
	RET

STORE:	JB RSTMODE1, STORE1 ; IF THE THIRD RESET MODE IS ON, JUMP TO STORE THE TEMPORARY PASSWORD

	MOV @R0, A		; STORE TO THE REGISTER POINTED BY R0 (INDIRECT ADDRESSING)
	MOV A, #2AH		; SHOW INPUTTED PASSWORD AS AN ASTERISK
	ACALL DISP		; DISPLAY IN LCD
	DJNZ R0, BACK	; CHECK IF 4 NUMBERS HAVE BEEN INPUTED

	MOV R0, #04H	; IF YES, VALIDATING INPUT
	MOV A, #01H		; CLEAR LCD
	ACALL COMM		
	SJMP VERIFY		; IF NOT, JUMP TO VERIFY FOR NORMAL VERIFICATION

STORE1: SETB PSW.4	; SET RAM TO REGISTER BANK 3
	SETB PSW.3
	MOV R1, A		; MOV THE INPUTTED RESULT TO R1
	MOV A, 00H		; MOV THE ITERATOR R0 IN REGISTER BANK 0 TO ACCUMULATOR
	ADD A, #28H		; ADD IT TO THE RAM HIGHER THAN THE CURRENTLY STORED PASSWORD TO STORE TEMPORARY NEW PASSWORD
	MOV R0, A		; MOV THE ADDRESS TO R0
	MOV A, R1		; MOV THE RESULT OF R1 TO ACCUMULATOR
	MOV @R0, A		; MOV THE VALUE TO THE ADDRESS POINTED BY R0
	MOV A, #2AH		; DISPLAY IN LCD
	ACALL DISP
	CLR PSW.4		; RETURN BACK TO REGISTER BANK 0
	CLR PSW.3
	DJNZ R0, BACK	; CHECK IF 4 NUMBERS HAVE BEEN INPUTED

	CLR RSTMODE1	; IF YES, CLEAR THE THIRD RESET MODE 
	SETB RSTMODE2	; SET TO THE FOURTH RESET MODE
	MOV R0, #04H	; RESET THE ITERATOR FOR VALIDATING INPUT
	MOV A, #01H		; CLEAR LCD
	ACALL COMM
	MOV A, #80H		; SET THE POINTER OF LCD TO 1st ROW, 1st COLUMN
	ACALL COMM
	MOV DPTR, #CFMPASSTXT	; DISPLAY THE CONFIRM PASSWORD TEXT
	ACALL READSTR	
	MOV A, #0C6H	; SET THE POINTER OF LCD TO 2nd ROW, 7th COLUMN
	ACALL COMM
	LJMP CHECK		; BACK TO LISTENING INPUT FROM KEYPAD
	
BACK:	ACALL SLEEP	; RETURN TO THE KEYPAD FOR SOME MORE INPUTS
	LJMP CHECK

; ===== VERIFY SECTION =====
VERIFY:	MOV A, @R0	; MOVE THE VALUE POINTED BY THE ITERATOR TO ACCUMULATOR
	SETB PSW.4		; SET RAM TO REGISTER BANK 3
	SETB PSW.3
	MOV R2, A		; MOVE THE VALUE IN ACCUMULATOR TO R2

	JB RSTMODE2, VERIFY2	; IF IN FOURTH RESET MODE, JUMP TO VERIFY THE NEW INPUTTED PASSWORD

	MOV A, 00H		; MOVE THE ITERATOR R0 IN REGISTER BANK 0 TO ACCUMULATOR
	ADD A, #20H		; ADD UP TO ACCESS THE ADDRESS WHERE THE PASSWORD IS STORED
	MOV R1, A		; MOVE THE VALUE TO R1
	MOV A, @R1		; LOOKUP FOR THE ADDRESS VALUE POINTED BY R1 AND STORE TO ACCUMULATOR
	XRL A, R2		; XOR A WITH THE VALUE STORED IN R2
	CLR PSW.4		; SET BACK TO REGISTER BANK 0
	CLR PSW.3
	MOV R6, A		; MOVE THE RESULT TO R6 (DIRECT ADDRESSING)
	CJNE R6, #00H, ERRBACK	; CHECK IF R6 VALUE IS NOT 0 (0 MEANS PIN IS INCORRECT)
	DJNZ R0, VERIFY	; CHECK IF 4 NUMBERS HAVE BEEN VALIDATED AND CORRECT

	JNB RSTCALL, OPEN	; CHECK IF RESET MODE HAS BEEN ACTIVATED
	CLR RSTCALL		; THE PASSWORD IS VALID, CLEAR THE SECOND RESET MODE
	SETB RSTMODE1	; SET THIRD RESET MODE
	MOV R0, #04H	; RESET THE ITERATOR
	MOV A, #01H		; CLEAR LCD
	ACALL COMM
	MOV A, #82H		; SET THE POINTER IN LCD TO 1st ROW, 3rd COLUMN
	ACALL COMM
	MOV DPTR, #NEWPASSTXT	; PRINT OUT NEW PASSWORD TEXT IN LCD
	ACALL READSTR
	MOV A, #0C6H	; SET THE POINTER IN LCD TO 2nd ROW, 7th COLUMN
	ACALL COMM
	LJMP CHECK		; BACK TO LISTENING INPUT FROM KEYPAD

VERIFY2: MOV A, 00H		; MOVE THE ITERATOR R0 IN REGISTER BANK 0 TO ACCUMULATOR
	ADD A, #28H		; ADD UP TO ACCESS THE ADDRESS WHERE THE NEW TEMPORARY PASSWORD IS STORED
	MOV R1, A		; MOVE THE VALUE TO R1 AS THE LOCATION ADDRESS OF THE TEMPORARY PASSWORD
	MOV A, @R1		; MOVE THE VALUE POINTED BY R1 TO ACCUMULATOR
	XRL A, R2		; XOR A WITH THE VALUE STORED IN R2
	CLR PSW.4		; SET BACK TO REGISTER 0
	CLR PSW.3
	MOV R6, A		; MOVE THE RESULT TO R6 (DIRECT ADDRESSING)
	CJNE R6, #00H, ERRBACK	; CHECK IF R6 VALUE IS NOT 0 (0 MEANS PIN IS INCORRECT)
	DJNZ R0, VERIFY	; CHECK IF 4 NUMBERS HAVE BEEN VALIDATED AND CORRECT

	MOV R0, #04H	; RESET THE ITERATOR
	SJMP RSTSTORE	; STORE THE PASSWORD

; ====== OPEN THE SAFE ======
OPEN:	SETB P1.2		; LIGHT UP THE GREEN LED
	MOV A, #86H		; SET LCD CURSOR TO 1st ROW, 7th COLUMN
	ACALL COMM
	MOV DPTR, #OPNTXT	; DISPLAY THE SUCCCESS TEXT
	ACALL READSTR
	ACALL SRVOPEN	; OPEN THE LOCK WITH SERVO
	JB P1.0, $		; WAIT TILL PUSH BUTTON HAS BEEN PRESSED
	CLR P1.2		; TURN OFF THE GREEN LED
	ACALL SRVCLR	; CLOSE THE LOCK WITH SERVO
	LJMP INIT		; RETURN BACK TO START
	
ERRBACK:SETB P1.1	; ERROR IN VALIDATING, LIGHT UP THE RED LED
	CLR RSTCALL
	CLR RSTMODE2
	MOV A, #84H		; SET LCD CURSOR TO 1st ROW, 5th COLUMN
	ACALL COMM
	MOV DPTR, #ERRTXT	; DISPLAY THE FIRST ERROR TEXT
	ACALL READSTR
	MOV A, #0C4H		; SET LCD CURSOR TO 2nd ROW, 5th COLUMN
	ACALL COMM
	MOV DPTR, #PWDTXT	; DISPLAY THE SECOND ERROR TEXT
	ACALL READSTR
	ACALL DELAY		; DELAY FOR 1S
	LJMP INIT		; RETURN BACK TO START

RSTSTORE: MOV A, @R0	; MOVE THE VALUE POINTED BY THE ITERATOR TO ACCUMULATOR
	SETB PSW.4		; SET RAM TO REGISTER BANK 3
	SETB PSW.3
	MOV R1, A		; MOVE ACCUMULATOR VALUE TO R1
	MOV A, 00H		; MOV THE ITERATOR R0 IN REGISTER BANK 0 TO ACCUMULATOR
	ADD A, #20H		; ADD UP TO ACCESS THE ADDRESS WHERE THE PASSWORD IS STORED
	MOV R0, A		; PUT THE A (THE ADDRESS WHERE PASS WILL BE STORED) TO R0
	MOV A, R1		; MOVE THE VALUE FROM R1 BACK TO ACCUMULATOR
	MOV @R0, A		; MOVE TO THE ADDRESS WHERE R0 POINTS TO
	CLR PSW.4		; CHANGE BACK TO REGISTER BANK 0
	CLR PSW.3
	DJNZ R0, RSTSTORE	; ITERATE UNTIL 4 PINS HAVE BEEN 
	
	CLR RSTMODE2	; CLEAR THE FOURTH RESET STATE
	MOV A, #84H		; SET LCD CURSOR TO 1st ROW, 5th COLUMN
	ACALL COMM
	MOV DPTR, #SUCCESSTXT	; DISPLAY THE SUCCESS MESSAGE
	ACALL READSTR
	ACALL DELAY		; DELAY FOR 1S
	LJMP INIT		; RETURN BACK TO START

; ===== LCD SECTIONS =====
COMM:   ACALL SLEEP ; QUICK DELAY
    MOV P3, A		; SET THE DATA PIN FROM ACCUMULATOR
    CLR P1.5 ; RS
    CLR P1.6 ; RW
    SETB P1.7 ; EN
    CLR P1.7 ; EN
    RET

READSTR: MOV A, #00H ; NULLIFY THE ACCUMULATOR
	MOVC A, @A+DPTR	; FETCH THE ASCII CODE USING INDEXED ADDRESSING
	JZ RDRET		; CHECK IF THE ACCUMULATOR'S VALUE IS 0

	ACALL DISP		; IF NOT, DISPLAY THE CHARACTER TO LCD
	INC DPTR		; INCREMENT DPTR SO NEXT CHARACTER IS BEING FETCHED
	SJMP READSTR	; RETURN BACK TO FETCH ANOTHER CHARACTER

RDRET:	RET

DISP:   ACALL SLEEP	; QUICK DELAY
    MOV P3, A		; SET THE DATA PIN FROM ACUMULATOR
    SETB P1.5 ; RS
    CLR P1.6  ; RW
    SETB P1.7 ; EN
    CLR P1.7  ; EN
    RET

; ===================================================
; | CREATE A PULSE OF 1.5ms FOR SERVO TO GO 0 DEGREE
; | TO DO IS DO FFFF - FA25 + 1 = 05DB = 1500 DEC   
; | SO WE SET TH AND TL TO FA AND 25 SO THE TIMER   
; | WILL COUNT TO 1 0000 WITH 1 IS TF0 (CARRY)      
; ===================================================
SRVCLR:	MOV TH0, #0FAH 
    MOV TL0, #24H 
    SETB P1.3 	; SET SERVO PIN TO HIGH
    SETB TR0 	; START THE TIMER
    JNB TF0, $ 	; WAIT TILL TF0 IS ON
    CLR P1.3 	; CLEAR SERVO PIN BIT
    CLR TF0 	; CLEAR THE FLAG MANUALLY
    CLR TR0 	; STOP THE TIMER
    RET 

; ====================================================
; | CREATE A PULSE OF 2.0ms FOR SERVO TO GO 90 DEGREE
; | TO DO IS DO FFFF - F830 + 1 = 07D0 = 2000 DEC   
; | SO WE SET TH AND TL TO F8 AND 30 SO THE TIMER   
; | WILL COUNT TO 1 0000 WITH 1 IS TF0 (CARRY)      
; ====================================================
SRVOPEN: MOV TH0, #0F8H 
    MOV TL0, #30H 
    SETB P1.3 	; SET SERVO PIN TO HIGH
    SETB TR0 	; START THE TIMER
    JNB TF0, $ 	; WAIT TILL TF0 IS ON
    CLR P1.3 	; CLEAR SERVO PIN BIT
    CLR TF0 	; CLEAR THE FLAG MANUALLY
    CLR TR0 	; STOP THE TIMER
    RET 

; ===== TIMER SECTION =====
SLEEP:  MOV R7, #01H; QUICK DELAY (65ms)
	SJMP TIMER		
DELAY:	MOV R7, #2AH; DELAY FOR approx. 3s
TIMER:	MOV TMOD, #01H	; TIMER LOGIC
	SETB TR0
	JNB TF0, $
	CLR TR0
	CLR TF0
	DJNZ R7, TIMER
	RET

; LCD WORDS TO BE DISPLAYED

PWDTXT: DB 'PASSWORD', 0
RSTTXT: DB 'CURRENT PASSWORD'
ERRTXT: DB 'INCORRECT', 0
OPNTXT: DB 'OPEN', 0
NEWPASSTXT: DB 'NEW PASSWORD', 0
CFMPASSTXT: DB 'CONFIRM PASSWORD', 0
SUCCESSTXT: DB 'SUCCESS!', 0

ORG 500H
PASS: 	DB 04H, 03H, 02H, 01H

END