;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Fri Apr 9 2021
; Processor: AT89C51
; Compiler:  ASEM-51 (Proteus)
;====================================================================

$NOMOD51
$INCLUDE (8051.MCU)

DATAPASS EQU 500H
PRESSED BIT 0H
RSTSIG BIT 0H	; BYTE FOR CALLING RESET SIGNAL
RSTCALL BIT 0H	; BYTE FOR SIGNALING RESET COMMAND
RSTMODE1 BIT 0H ; RESET MODE FOR NEW PASSWORD
RSTMODE2 BIT 0H ; RESET MODE FOR CONFIRM PASSWORD

ORG 00H
	MOV P1, #0F9H	; SWITCH, PUSH BUTTON, LCD PIN
	MOV P2, #0FFH	; KEYPAD
	MOV R0, #04H
	MOV DPTR, #DATAPASS
MOVPWD: MOV A, R0
	SETB PSW.4
	MOV R0, A
	DEC A
	MOVC A, @A+DPTR
	MOV @R0, A
	CLR PSW.4
	DJNZ R0, MOVPWD

	; LCD INITIALIZATION
	MOV A, #38H		; 16x2, 5x7 DOT MATRIC DISPLAY
	ACALL COMM
	MOV A, #0CH		; SET LCD DISPLAY ON, CURSOR OFF, BLINKING OFF
	ACALL COMM
	
INIT:	MOV A, #01H		; CLEAR THE DISPLAY
	ACALL COMM
	MOV P2, #0FFH ; NULLIFY ALL I/O PORT
	MOV P1, #0F9H
	MOV R0, #04H

	JNB RSTSIG, INIT2	; GO TO NORMAL INITIALIZATION
	ACALL DORST
	MOV A, #80H
	ACALL COMM
	MOV DPTR, #RSTTXT	; DISPLAY THE RESET TEXT
	ACALL READSTR
	MOV A, #0C6H
	ACALL COMM
	SJMP CHECK

INIT2:	MOV A, #84H		; SET LCD CURSOR TO 1st ROW, 4th COLUMN
	ACALL COMM
	MOV DPTR, #PWDTXT	; DISPLAY THE PASSWORD TEXT
	ACALL READSTR
	MOV A, #0C6H	; SET LCD CURSOR TO 2nd ROW, 6th COLUMN
	ACALL COMM

; === KEYPAD CODE, A TO D AS OUTPUT, 1 TO 3 AS INPUT ===
CHECK:	MOV A, #01H ; RANGE 1-3, 1 AS DEFAULT
	MOV P2, #0FEH	; SET ACTIVE BIT TO P2.0
	ACALL COLCHK	; CHECK INPUT

	JB PRESSED, STORE	; STORE IF THERE IS INPUT

	MOV A, #04H		; RANGE 4-6, 4 AS DEFAULT
	MOV P2, #0FDH	; SET ACTIVE BIT TO P2.1
	ACALL COLCHK	; CHECK INPUT

	JB PRESSED, STORE	; STORE IF THERE IS INPUT

	MOV A, #07H		; RANGE 7-9, 7 AS DEFAULT
	MOV P2, #0FBH	; SET ACTIVE BIT TO P2.2
	ACALL COLCHK

	JB PRESSED, STORE

	MOV A, #00H		; ONLY 0 EXIST IN THIS ROW
	MOV P2, #0F7H	; SET ACTIVE BIT TO P2.3
	ACALL COLRST	; CHECK IF * OR 0 WAS PRESSED

	JB PRESSED, STORE
	JB RSTSIG, INIT

	JMP CHECK	; NOTHING, BACK TO CHECKING

DORST:	CLR RSTSIG	; CLEAR RESET SO THAT IT WONT BE DETECTED BY KEYPAD
	SETB RSTCALL 	; MOVE THE VALUE TO RSTCALL
	RET

COLCHK:	CLR PRESSED	; SET BOOLEAN TO FALSE

	JB P2.4, COL_2	; NOTHING PRESSED IN (1), MOVE TO NEXT COL
	JNB P2.4, $		; WAIT UNTIL BUTTON HAS BEEN RELEASED 
	SETB PRESSED	; BUTTON HAS BEEN PRESSED, SET BOOLEAN TO TRUE
	RET

COL_2:	JB P2.5, COL_3	; NOTHING PRESSED 
	JNB P2.5, $		; WAIT TILL BUTTON HAS BEEN RELEASED
	INC A			; ADD DEFAULT VALUE BY 1
	SETB PRESSED	; SET BOOLEAN TO TRUE
	RET

COL_3:	JB P2.6, RETURN	; NOTHING HAS BEEN PRESSED HERE. CURRENT ROW DOESN'T HAVE ANY INPUT
	JNB P2.6, $		; WAIT TILL BUTTON HAS BEEN RELEASED
	INC A			; ADD DEFAULT VALUE BY 2
	INC A
	SETB PRESSED

; == RETURN TO LAST ACALL ==
RETURN:	RET

; ===== STORE SECTION =====
COLRST: JB P2.4, COLZERO ; NOTHING HAS BEEN PRESSED
	JB P2.4, $
	JB RSTCALL, COLZERO	; IN RESET MODE, SKIP THIS!
	JB RSTMODE1, COLZERO
	JB RSTMODE2, COLZERO
	SETB RSTSIG
	RET

COLZERO:JB P2.5, RETURN	; NOTHING HAS BEEN PRESSED HERE. NO INPUT
	JNB P2.5, $
	SETB PRESSED
	RET

STORE:	JB RSTMODE1, STORE1
	MOV @R0, A	; STORE TO THE REGISTER POINTED BY R0 (INDIRECT ADDRESSING)
	MOV A, #2AH		; SHOW INPUTTED PASSWORD AS AN ASTERISK
	ACALL DISP		; DISPLAY IN LCD
	DJNZ R0, BACK	; CHECK IF 4 NUMBER HAS BEEN INPUT
	MOV R0, #04H	; IF YES, VALIDATING INPUT
	MOV A, #01H		; CLEAR LCD
	ACALL COMM
	JB RSTMODE2, VERIFY2
	SJMP VERIFY
STORE1:	MOV R7, A
	MOV A, R0
	SETB PSW.3
	MOV R0, A
	MOV A, 07H
	MOV @R0, A
	CLR PSW.3
	MOV A, #2AH		; SHOW INPUTTED PASSWORD AS AN ASTERISK
	ACALL DISP		; DISPLAY IN LCD
	DJNZ R0, BACK	; CHECK IF 4 NUMBER HAS BEEN INPUT
	CLR RSTMODE1
	SETB RSTMODE2
	MOV R0, #04H	; IF YES, CONFIRM NEW PASSWORD
	MOV A, #01H		; CLEAR LCD
	ACALL COMM
	MOV A, #80H
	ACALL COMM
	MOV DPTR, #CFMPASSTXT
	ACALL READSTR
	MOV A, #0C6H
	ACALL COMM
	LJMP CHECK
	
BACK:	ACALL SLEEP	; RETURN TO THE KEYPAD FOR SOME MORE INPUTS
	LJMP CHECK

; ===== VERIFY SECTION =====
VERIFY:	MOV A, R0	; MOVE THE CURRENT ITERATOR TO ACCUMULATOR
	ADD A, #0FFH	; ADD SO THAT A POINT OUT THE PASSWORD LOCATION
	MOV 0FFH, R0	; MOVE R0 TO TEMPORARY LOCATION
	MOV R0, A		; MOV A TO R0
	MOV A, @R0		; MOV PASSWORD VALUE TO A
	MOV R0, 0FFH	; MOVE BACK FROM TEMP LOCATION TO R0
	XRL A, @R0		; XOR A WITH THE REGISTER THE ITERATOR IS POINTING TO (INDIRECT ADDRESSING)
	MOV R6, A		; MOVE THE RESULT TO R6 (DIRECT ADDRESSING)
	CJNE R6, #00H, ERRBACK	; CHECK IF R6 VALUE IS NOT 0 (0 MEANS PIN IS INCORRECT)
	DJNZ R0, VERIFY	; CHECK IF 4 NUMBER HAS BEEN VALIDATED AND CORRECT
	JNB RSTCALL, OPEN	; JUMP IF NOT IN RESET MODE, TO OPEN THE SAFE
	CLR RSTCALL
	SETB RSTMODE1
	MOV R0, #04H	; IF YES, REQUEST NEW PASSWORD
	MOV A, #01H		; CLEAR LCD
	ACALL COMM
	MOV A, #82H
	ACALL COMM
	MOV DPTR, #NEWPASSTXT
	ACALL READSTR
	MOV A, #0C6H
	ACALL COMM
	LJMP CHECK


VERIFY2:MOV A, R0	; MOVE THE CURRENT ITERATOR TO ACCUMULATOR
	ADD A, #08H
	MOV 0FFH, R0
	MOV R0, A
	MOV A, @R0
	MOV R0, 0FFH
	XRL A, @R0
	MOV R6, A
	CJNE R6, #00H, ERRBACK
	DJNZ R0, VERIFY2
	MOV R0, #04H
	SJMP RSTSTORE

; VALIDATED PIN CODE GOES HERE
OPEN:	SETB P1.2		; LIGHT UP THE GREEN LED
	MOV A, #86H		; SET LCD CURSOR TO 1st ROW, 6th COLUMN
	ACALL COMM
	MOV DPTR, #OPNTXT	; DISPLAY THE SUCCCESS TEXT
	ACALL READSTR
	JB P1.0, $		; WAIT TILL PUSH BUTTON HAS BEEN PRESSED
	CLR P1.2		; TURN OFF THE GREEN LED
	LJMP INIT		; RETURN BACK TO START
	
ERRBACK:SETB P1.1	; ERROR IN VALIDATING, LIGHT UP THE RED LED
	CLR RSTCALL
	CLR RSTMODE2
	MOV A, #84H		; SET LCD CURSOR TO 1st ROW, 4th COLUMN
	ACALL COMM
	MOV DPTR, #ERRTXT	; DISPLAY THE FIRST ERROR TEXT
	ACALL READSTR
	MOV A, #0C4H		; SET LCD CURSOR TO 2nd ROW, 4th COLUMN
	ACALL COMM
	MOV DPTR, #PWDTXT	; DISPLAY THE SECOND ERROR TEXT
	ACALL READSTR
	ACALL DELAY		; DELAY FOR 1S
	LJMP INIT		; RETURN BACK TO START

RSTSTORE:	MOV A, R0
	SETB PSW.4
	MOV R0, A
	CLR PSW.4
	MOV A, @R0
	SETB PSW.4
	MOV @R0, A
	CLR PSW.4
	DJNZ R0, RSTSTORE
	MOV A, #84H
	ACALL COMM
	MOV DPTR, #SUCCESSTXT
	ACALL READSTR
	ACALL DELAY
	LJMP INIT

; ===== LCD SECTIONS =====
COMM:   ACALL SLEEP ; QUICK DELAY
    MOV P3, A		; SET THE DATA PIN FROM ACCUMULATOR
    CLR P1.5 ; RS
    CLR P1.6 ; RW
    SETB P1.7 ; EN
    CLR P1.7 ; EN
    RET

READSTR: MOV A, #00H ; NULLIFY THE ACCUMULATOR
	MOVC A, @A+DPTR	; FETCH THE ASCII CODE USING INDEXED ADDRESSING
	JZ RETURN2		; CHECK IF THE ACCUMULATOR'S VALUE IS 0
	ACALL DISP		; IF NOT, DISPLAY THE CHARACTER TO LCD
	INC DPTR		; INCREMENT DPTR SO NEXT CHARACTER IS BEING FETCHED
	SJMP READSTR	; RETURN BACK TO FETCH ANOTHER CHARACTER

RETURN2: RET	; ANOTHER FUNCTION SO THAT READSTR IS NOT OUT OF RANGE WHEN JUMPING

DISP:   ACALL SLEEP	; QUICK DELAY
    MOV P3, A		; SET THE DATA PIN FROM ACUMULATOR
    SETB P1.5 ; RS
    CLR P1.6 ; RW
    SETB P1.7 ; EN
    CLR P1.7 ; EN
    RET

; ===== TIMER SECTION =====
SLEEP:  MOV R7, #01H; QUICK DELAY (65ms)
	SJMP TIMER		
DELAY:	MOV R7, #2AH; DELAY FOR approx. 3s
TIMER:	MOV TMOD, #01H	; TIMER LOGIC
	SETB TR0
	JNB TF0, $
	CLR TR0
	CLR TF0
	DJNZ R7, TIMER
	RET

; LCD WORDS TO BE DISPLAYED

PWDTXT: DB 'PASSWORD', 0
RSTTXT: DB 'CURRENT PASSWORD'
ERRTXT: DB 'INCORRECT', 0
OPNTXT: DB 'OPEN', 0
NEWPASSTXT: DB 'NEW PASSWORD', 0
CFMPASSTXT: DB 'CONFIRM PASSWORD', 0
SUCCESSTXT: DB 'SUCCESS!', 0

ORG 500H
PASS: 	DB 04H, 03H, 02H, 01H

END